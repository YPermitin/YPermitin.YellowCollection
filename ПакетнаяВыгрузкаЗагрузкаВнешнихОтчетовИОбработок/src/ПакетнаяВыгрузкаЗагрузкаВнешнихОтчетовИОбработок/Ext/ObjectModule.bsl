
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Сведения о внешней обработке
// 
// Возвращаемое значение:
//   - Структура - Информация о внешнем отчете и обработке
//
Функция СведенияОВнешнейОбработке() Экспорт 
	
	РегистрационныеДанные = Новый Структура;
	РегистрационныеДанные.Вставить("Наименование", НСтр("ru='Пакетная выгрузка / загрузка внешних отчетов и обработок'"));
	РегистрационныеДанные.Вставить("БезопасныйРежим", Ложь);
	РегистрационныеДанные.Вставить("Версия", "1.0.0.4");
	РегистрационныеДанные.Вставить("ВерсияБСП", "");
	РегистрационныеДанные.Вставить("Вид", "ДополнительнаяОбработка");
	РегистрационныеДанные.Вставить("Информация", 
		НСтр("ru='Обработка ""Пакетная выгрузка / загрузка внешних отчетов и обработок"" предназначен для пакетной выгрузки и загрузки 
		|внешних отчетов и обработок.'"));
		
	МассивНазначенийОбработки = НазначениеОбработки();
	РегистрационныеДанные.Вставить("Назначение", МассивНазначенийОбработки);
	
	ТаблицаКомандОбработки = ТаблицаКомандОбработки();
	РегистрационныеДанные.Вставить("Команды", ТаблицаКомандОбработки);
		
	Возврат РегистрационныеДанные;
	
КонецФункции

// Заполняет таблицу объектов для выгрузки
// в соответствии с настройками
//
// Параметры:
// 	МассивЭлементов - Массив - Массив ссылок на внешние отчеты и обработки для отбора
//
Процедура ЗаполнитьТаблицуВыгрузки(МассивЭлементов = Неопределено) Экспорт
	
	ОбъектыДляВыгрузки.Очистить();
	
	Если НЕ ЗначениеЗаполнено(МетаданныеСправочника)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитПредставление)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитИмя)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитПредставление) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ПоддерживаютсяГруппы = СправочникИерархическийСГрупами();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ДополнительныеОтчетыИОбработки.Ссылка КАК Ссылка,
		|	ДополнительныеОтчетыИОбработки.Наименование КАК Представление,
		|	ДополнительныеОтчетыИОбработки.ИмяОбъекта КАК Имя,
		|	ДополнительныеОтчетыИОбработки.Вид КАК Вид,
		|	ВЫБОР
		|		КОГДА ДополнительныеОтчетыИОбработки.ПометкаУдаления
		|			ТОГДА 1
		|		ИНАЧЕ 0
		|	КОНЕЦ КАК Порядок
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
		|ГДЕ
		|	&ПоддерживаютсяГруппы
		|	И &ФильтрПоСсылке
		|
		|УПОРЯДОЧИТЬ ПО
		|	Имя,
		|	Порядок";
	
	Если ПоддерживаютсяГруппы Тогда
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ПоддерживаютсяГруппы",
			"ЭтоГруппа = ЛОЖЬ");
	Иначе
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ПоддерживаютсяГруппы",
			"Истина");
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"Справочник.ДополнительныеОтчетыИОбработки",
		"Справочник." + МетаданныеСправочника);
	
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"ДополнительныеОтчетыИОбработки.ИмяОбъекта",
		"ДополнительныеОтчетыИОбработки." + РеквизитИмя);
		
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"ДополнительныеОтчетыИОбработки.Вид",
		"ДополнительныеОтчетыИОбработки." + РеквизитВид);
		
	Если МассивЭлементов = Неопределено Тогда
		
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ФильтрПоСсылке",
			"ИСТИНА");
		
	Иначе
		
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ФильтрПоСсылке",
			"Ссылка В (&МассивСсылок)");
			
		Запрос.УстановитьПараметр("МассивСсылок", МассивЭлементов);
		
	КонецЕсли;
		
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаЭлементы = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаЭлементы.Следующий() Цикл
		
		СтруктураПоиска = Новый Структура("Имя", ВыборкаЭлементы.Имя);
		ПоискСуществующихОбъектов = ОбъектыДляВыгрузки.НайтиСтроки(СтруктураПоиска);
		КоличествоСуществующих = ПоискСуществующихОбъектов.Количество();
		Если КоличествоСуществующих = 0 Тогда
			ПостфиксИмени = "";	
		Иначе
			ПостфиксИмени = "_" + XMLСтрока(КоличествоСуществующих);
		КонецЕсли;
		
		ЭлементВыгрузки = ОбъектыДляВыгрузки.Добавить();	
		ЭлементВыгрузки.Выбран = Истина;
		ЭлементВыгрузки.Имя = ВыборкаЭлементы.Имя + ПостфиксИмени;
		ЭлементВыгрузки.Представление = ВыборкаЭлементы.Представление;
		ЭлементВыгрузки.УникальныйИдентификатор = ВыборкаЭлементы.Ссылка.УникальныйИдентификатор();
		ЭлементВыгрузки.Ссылка = ВыборкаЭлементы.Ссылка;
		ЭлементВыгрузки.Вид = ОпределитьТипВнешнегоОбъекта(ВыборкаЭлементы.Вид);		
		ЭлементВыгрузки.РезультатОперации = 0;
		
	КонецЦикла;
	
КонецПроцедуры

// Получает двоичные данные внешнего отчета / обработки
//
// Параметры:
//  СсылкаНаОбъект	 - СправочникСсылка - Ссылка на элемент справочника с внешним отчетом или обработкой
// 
// Возвращаемое значение:
//   - ДвоичныеДанные - Двоичные данные файла внешнего отчета или обработки
//
Функция ДвоичныеДанныеОбъекта(СсылкаНаОбъект) Экспорт
	
	ПоддерживаютсяГруппы = СправочникИерархическийСГрупами();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ДополнительныеОтчетыИОбработки.ХранилищеОбработки КАК ХранилищеОбработки
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
		|ГДЕ
		|	ДополнительныеОтчетыИОбработки.Ссылка = &Ссылка
		|	И &ПоддерживаютсяГруппы";	
	Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	
	Если ПоддерживаютсяГруппы Тогда
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ПоддерживаютсяГруппы",
			"ЭтоГруппа = ЛОЖЬ");
	Иначе
		Запрос.Текст = СтрЗаменить(
			Запрос.Текст,
			"&ПоддерживаютсяГруппы",
			"Истина");
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"Справочник.ДополнительныеОтчетыИОбработки",
		"Справочник." + МетаданныеСправочника);
	
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"ДополнительныеОтчетыИОбработки.ХранилищеОбработки",
		"ДополнительныеОтчетыИОбработки." + РеквизитХранилище);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаХранилище = РезультатЗапроса.Выбрать();
	
	ДанныеОбъекта = Неопределено;
	
	Если ВыборкаХранилище.Следующий() Тогда
		
		ДанныеОбъекта = ВыборкаХранилище.ХранилищеОбработки.Получить();
		
	КонецЕсли;		
	
	Возврат ДанныеОбъекта;
	
КонецФункции

// Выгружает обработки в каталог на сервере
//
Процедура ВыгрузитьВКаталог() Экспорт
	
	Отказ = Ложь;	
	ОбработкаПроверкиЗаполненияПередВыгрузкой(Отказ);
	
	Если Отказ Тогда
		Возврат;
	КонецЕсли;	
	
	УдалитьФайлыПередВыгрузкой();
	
	ПутьФайлаКонфигурации = ОсновнойКаталогВыгрузки
			+ "\"
			+ "config.json";
			
	ДанныеФайлаКонфигурации = Новый Структура;
	ДанныеФайлаКонфигурации.Вставить("ДатаВыгрузки", ТекущаяДатаСеанса());
	ДанныеФайлаКонфигурации.Вставить("КоличествоОбъектов", ОбъектыДляВыгрузки.Количество());
	ДанныеФайлаКонфигурации.Вставить("Элементы", Новый Массив);
	
	Попытка
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.ОткрытьФайл(ПутьФайлаКонфигурации);
		ЗаписатьJSON(ЗаписьJSON, ДанныеФайлаКонфигурации);
		ЗаписьJSON.Закрыть();
		
	Исключение
		
		ТекстСообщения = "Не удалось инициализировать файл конфигурации выгрузки ''"
			+ ПутьФайлаКонфигурации + "''"
			+ Символы.ПС
			+ "Выгрузка не выполнена.";
				
		СообщитьПользователю(
			НСтр("ru = '" + ТекстСообщения + "'"),,,,				
			Отказ);
		
		Возврат;
		
	КонецПопытки;
	
	Для Каждого СтрокаОбъекта Из ОбъектыДляВыгрузки Цикл
		
		СтрокаОбъекта.РезультатОперации = 0;
		
		Если НЕ СтрокаОбъекта.Выбран Тогда
			Продолжить;
		КонецЕсли;
		
		ИндексСтроки = ОбъектыДляВыгрузки.Индекс(СтрокаОбъекта);
		
		ПутьФайлаВыгрузки = ОсновнойКаталогВыгрузки
			+ "\"
			+ ПодготовитьИмяФайла(СтрокаОбъекта.Имя)
			+ "."
			+ ?(СтрокаОбъекта.Вид = "Обработка", "epf", "erf");
			
		Попытка
			
			ДвоичныеОбъектаДляЗаписи = ДвоичныеДанныеОбъекта(СтрокаОбъекта.Ссылка);
			
			Если ДвоичныеОбъектаДляЗаписи = Неопределено Тогда
				
				СообщитьПользователю(
					НСтр("ru = 'Обработка не содержит двоичные данные в хранилище и не была выгружена в каталог.'"),,
					"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
					"Объект",				
					Отказ);
					
				СтрокаОбъекта.РезультатОперации = 2;
				
			Иначе
				
				ДвоичныеОбъектаДляЗаписи.Записать(ПутьФайлаВыгрузки);
				
				ПараметрыВыгрузкиОбработки = Новый Структура;
				ПараметрыВыгрузкиОбработки.Вставить("Представление", СтрокаОбъекта.Представление);
				ПараметрыВыгрузкиОбработки.Вставить("Имя", СтрокаОбъекта.Имя);
				ПараметрыВыгрузкиОбработки.Вставить("УникальныйИдентификатор", XMLСтрока(СтрокаОбъекта.УникальныйИдентификатор));
				ПараметрыВыгрузкиОбработки.Вставить("Вид", СтрокаОбъекта.Вид);
				ДанныеФайлаКонфигурации.Элементы.Добавить(ПараметрыВыгрузкиОбработки);
				
				СтрокаОбъекта.РезультатОперации = 1;
				
			КонецЕсли;
			
		Исключение
			
			ИнформацияОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ТекстСообщения = "Произошла непредвиденная ошибка при выгрузке:
				|
				|" + ИнформацияОбОшибке;
			
			СообщитьПользователю(
				НСтр("ru = '" + ТекстСообщения + "'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
				"Объект",				
				Отказ);
				
			СтрокаОбъекта.РезультатОперации = 2;
			
		КонецПопытки;
		
	КонецЦикла;
		
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ОткрытьФайл(ПутьФайлаКонфигурации);
	ЗаписатьJSON(ЗаписьJSON, ДанныеФайлаКонфигурации);
	ЗаписьJSON.Закрыть();
	
КонецПроцедуры

// Обновить таблицу загрузки в соответствии с настройками
//
Процедура ОбновитьТаблицуЗагрузки() Экспорт
	
	ОбъектыДляЗагрузки.Очистить();
	
	Если НЕ ЗначениеЗаполнено(ОсновнойКаталогЗагрузки) Тогда
		Возврат;
	КонецЕсли;
	
	ПутьФайлаКонфигурации = ОсновнойКаталогВыгрузки
			+ "\"
			+ "config.json";
			
	ФайлКонфигурации = Новый Файл(ПутьФайлаКонфигурации);
	Если ФайлКонфигурации.Существует() Тогда
			
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.ОткрытьФайл(ПутьФайлаКонфигурации);
		КонфигурацияЗагрузки = ПрочитатьJSON(ЧтениеJSON, Ложь);	
		
		Для Каждого ЭлементЗагрузки Из КонфигурацияЗагрузки.Элементы Цикл
			
			ОбъектЗагрузки = ОбъектыДляЗагрузки.Добавить();
			ОбъектЗагрузки.Выбран = Истина;
			ОбъектЗагрузки.Представление = ЭлементЗагрузки.Представление;
			ОбъектЗагрузки.Имя = ЭлементЗагрузки.Имя;
			ОбъектЗагрузки.УникальныйИдентификатор = Новый УникальныйИдентификатор(ЭлементЗагрузки.УникальныйИдентификатор);
			ОбъектЗагрузки.Вид = ЭлементЗагрузки.Вид;
						
			ОбъектЗагрузки.Ссылка = СсылкаНаСправочникПоУникальномуИдентификатору(ОбъектЗагрузки.УникальныйИдентификатор);
			Если НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
				ОбъектЗагрузки.Ссылка = ПустаяСсылкаНаСправочник();
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		МассивОбработок = НайтиФайлы(ОсновнойКаталогВыгрузки, "*.epf");
		МассивОтчет = НайтиФайлы(ОсновнойКаталогВыгрузки, "*.erf");
		
		Для Каждого ЭлементОбработка Из МассивОбработок Цикл
			
			ОбъектЗагрузки = ОбъектыДляЗагрузки.Добавить();
			ОбъектЗагрузки.Выбран = Истина;
			ОбъектЗагрузки.Представление = ЭлементОбработка.ИмяБезРасширения;
			ОбъектЗагрузки.Имя = ЭлементОбработка.ИмяБезРасширения;
			ОбъектЗагрузки.УникальныйИдентификатор = Неопределено;
			ОбъектЗагрузки.Вид = "Обработка";			
			
			ОпределитьСсылкуНаЭлементСправочника(ОбъектЗагрузки, ЭлементОбработка);
			
		КонецЦикла;
		
		Для Каждого ЭлементОтчет Из МассивОтчет Цикл
			
			ОбъектЗагрузки = ОбъектыДляЗагрузки.Добавить();
			ОбъектЗагрузки.Выбран = Истина;
			ОбъектЗагрузки.Представление = ЭлементОтчет.ИмяБезРасширения;
			ОбъектЗагрузки.Имя = ЭлементОтчет.ИмяБезРасширения;
			ОбъектЗагрузки.УникальныйИдентификатор = Неопределено;
			ОбъектЗагрузки.Вид = "Отчет";			
			
			ОпределитьСсылкуНаЭлементСправочника(ОбъектЗагрузки, ЭлементОтчет);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Загружает обработки из каталога на сервере
//
Процедура ЗагрузитьИзКаталога() Экспорт
	
	Отказ = Ложь;	
	ОбработкаПроверкиЗаполненияПередЗагрузкой(Отказ);
	
	Если Отказ Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ЭлементЗагрузки Из ОбъектыДляЗагрузки Цикл
		
		ЭлементЗагрузки.РезультатОперации = 0;
		
		Если НЕ ЭлементЗагрузки.Выбран Тогда
			Продолжить;
		КонецЕсли;
		
		ИндексСтроки = ОбъектыДляЗагрузки.Индекс(ЭлементЗагрузки);
		
		ПутьФайлаОбъекта = ОсновнойКаталогЗагрузки
			+ "\"
			+ ПодготовитьИмяФайла(ЭлементЗагрузки.Имя)
			+ "."
			+ ?(ЭлементЗагрузки.Вид = "Обработка", "epf", "erf");
			
		Попытка
			
			ДвоичныеДанныеОбъекта = Новый ДвоичныеДанные(ПутьФайлаОбъекта);
			
			ЗаписатьДанныеОбъектаВХранилище(ДвоичныеДанныеОбъекта,  ЭлементЗагрузки.Ссылка, ПутьФайлаОбъекта);
			
			Если ТранзакцияАктивна() Тогда
				ЗафиксироватьТранзакцию();
			КонецЕсли;
			
			ЭлементЗагрузки.РезультатОперации = 1;
			
		Исключение
			
			Если ТранзакцияАктивна() Тогда
				ОтменитьТранзакцию();
			КонецЕсли;
			
			ИнформацияОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ТекстСообщения = "Произошла непредвиденная ошибка при загрузке:
				|
				|" + ИнформацияОбОшибке;
			
			СообщитьПользователю(
				НСтр("ru = '" + ТекстСообщения + "'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
				"Объект");
				
			ЭлементЗагрузки.РезультатОперации = 2;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Обработка проверки заполнения перед выгрузкой
//
// Параметры:
//  Отказ	 - Булево - Если ИСТИНА, то есть ошибки заполнения
//
Процедура ОбработкаПроверкиЗаполненияПередВыгрузкой(Отказ) Экспорт
	
	ОбработкаПроверкиЗаполненияОбщая(Отказ);
	
	#Область ПроверкаРеквизитов
	
	Если НЕ ЗначениеЗаполнено(ОсновнойКаталогВыгрузки) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнен каталог выгрузки обработок.'"),,
			"ОсновнойКаталогВыгрузки",
			"Объект",				
			Отказ);
			
	КонецЕсли;
		
	#КонецОбласти	
	
	#Область ПроверкаТаблицыВыгрузки
	
	Для Каждого СтрокаВыгрузки Из ОбъектыДляВыгрузки Цикл
		
		Если НЕ СтрокаВыгрузки.Выбран Тогда
			Продолжить;
		КонецЕсли;
		
		НомерСтроки = СтрокаВыгрузки.НомерСтроки;
		ИндексСтроки = ОбъектыДляВыгрузки.Индекс(СтрокаВыгрузки);
		
		Если НЕ ЗначениеЗаполнено(СтрокаВыгрузки.Представление) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнено представление обработки.'"),,
				"ОбъектыДляВыгрузки[" + XMLСтрока(ИндексСтроки) +"].Представление",
				"Объект",				
				Отказ);
			
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(СтрокаВыгрузки.Имя) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнено имя обработки.'"),,
				"ОбъектыДляВыгрузки[" + XMLСтрока(ИндексСтроки) +"].Имя",
				"Объект",				
				Отказ);
			
		КонецЕсли;
			
		Если НЕ ЗначениеЗаполнено(СтрокаВыгрузки.Вид) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнен вид обработки.'"),,
				"ОбъектыДляВыгрузки[" + XMLСтрока(ИндексСтроки) +"].Вид",
				"Объект",				
				Отказ);
			
		КонецЕсли;	
		
		Если НЕ ЗначениеЗаполнено(СтрокаВыгрузки.Ссылка) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнена ссылка на внешнюю обработку.'"),,
				"ОбъектыДляВыгрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
				"Объект",				
				Отказ);
			
		КонецЕсли;
		
	КонецЦикла;
	
	#КонецОбласти
	
КонецПроцедуры

// Обработка проверки заполнения перед загрузкой
//
// Параметры:
//  Отказ	 - Булево - Если ИСТИНА, то есть ошибки заполнения
//
Процедура ОбработкаПроверкиЗаполненияПередЗагрузкой(Отказ) Экспорт
	
	ОбработкаПроверкиЗаполненияОбщая(Отказ);
	
	#Область ПроверкаРеквизитов
	
	Если НЕ ЗначениеЗаполнено(ОсновнойКаталогЗагрузки) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнен каталог загрузки обработок.'"),,
			"ОсновнойКаталогЗагрузки",
			"Объект",				
			Отказ);
			
	КонецЕсли;
	
	#КонецОбласти
	
	#Область ПроверкаТаблицыЗагрузки
	
	Для Каждого СтрокаЗагрузки Из ОбъектыДляЗагрузки Цикл
		
		Если НЕ СтрокаЗагрузки.Выбран Тогда
			Продолжить;
		КонецЕсли;
		
		ИндексСтроки = ОбъектыДляЗагрузки.Индекс(СтрокаЗагрузки);
		
		Если НЕ ЗначениеЗаполнено(СтрокаЗагрузки.Представление) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнено представление обработки.'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Представление",
				"Объект",				
				Отказ);
			
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(СтрокаЗагрузки.Имя) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнено имя обработки.'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Имя",
				"Объект",				
				Отказ);
			
		КонецЕсли;
			
		Если НЕ ЗначениеЗаполнено(СтрокаЗагрузки.Вид) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнен вид обработки.'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Вид",
				"Объект",				
				Отказ);
			
		КонецЕсли;	
		
		Если НЕ ЗначениеЗаполнено(СтрокаЗагрузки.Ссылка) Тогда
						
			СообщитьПользователю(
				НСтр("ru = 'Не заполнена ссылка на внешнюю обработку.'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
				"Объект",				
				Отказ);
			
		КонецЕсли;
		
	КонецЦикла;
	
	#КонецОбласти
	
	#Область ПроверкаДублейСсылокЗагрузки
	
	ТаблицаПодсчетаДублейСсылок = Новый ТаблицаЗначений;
	ТаблицаПодсчетаДублейСсылок.Колонки.Добавить("Ссылка");
	ТаблицаПодсчетаДублейСсылок.Колонки.Добавить("Количество");
	
	Для Каждого СтрокаЗагрузки Из ОбъектыДляЗагрузки Цикл
		
		Если НЕ СтрокаЗагрузки.Выбран Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(СтрокаЗагрузки.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураПоиска = Новый Структура("Ссылка", СтрокаЗагрузки.Ссылка);
		РезультатПоиска = ТаблицаПодсчетаДублейСсылок.НайтиСтроки(СтруктураПоиска);
		
		Если РезультатПоиска.Количество() > 0 Тогда
			ЗаписьПроверки = РезультатПоиска.Получить(0);	
		Иначе
			ЗаписьПроверки = ТаблицаПодсчетаДублейСсылок.Добавить();
			ЗаписьПроверки.Ссылка = СтрокаЗагрузки.Ссылка;
			ЗаписьПроверки.Количество = 0;
		КонецЕсли;
		
		ЗаписьПроверки.Количество = ЗаписьПроверки.Количество + 1;
		
	КонецЦикла;
	
	ТаблицаПодсчетаДублейСсылок.Сортировать("Количество Убыв");
	
	Для Каждого СтрокаДубль Из ТаблицаПодсчетаДублейСсылок Цикл
		
		Если СтрокаДубль.Количество <= 1 Тогда
			Прервать;
		КонецЕсли;
		
		СтруктураПоиска = Новый Структура("Ссылка, Выбран", СтрокаДубль.Ссылка, Истина);
		СтрокиЗагрузки = ОбъектыДляЗагрузки.НайтиСтроки(СтруктураПоиска);
		
		Для Каждого СтрокаЗагрузки Из СтрокиЗагрузки Цикл
			
			ИндексСтроки = ОбъектыДляЗагрузки.Индекс(СтрокаЗагрузки);	
			
			СообщитьПользователю(
				НСтр("ru = 'Дубль выбранной ссылки для загрузки.'"),,
				"ОбъектыДляЗагрузки[" + XMLСтрока(ИндексСтроки) +"].Ссылка",
				"Объект",				
				Отказ);
			
		КонецЦикла;
		
	КонецЦикла;
	
	#КонецОбласти
	
КонецПроцедуры

// Определить ссылку на элемент справочника для строки таблицы загрузки
//
// Параметры:
//  ОбъектЗагрузки	 - Объект.ОбъектыДляЗагрузки.Строка	- Строка таблицы загруки
//  ЭлементОтчет	 - Файл - Описание файла внешнего отчета / обработки
//
Процедура ОпределитьСсылкуНаЭлементСправочника(Знач ОбъектЗагрузки, Знач ЭлементОтчет) Экспорт
	
	Если ДоступнаПодсистемаДополнительныеОтчетыИОбработки
		И НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
		
		ОбъектЗагрузки.Ссылка = СсылкаНаСправочникПоРегистрационнымДанным(ЭлементОтчет.ПолноеИмя);
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
		ОбъектЗагрузки.Ссылка = СсылкаНаСправочникПоИмениОбъекта(ОбъектЗагрузки.Имя);
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
		ОбъектЗагрузки.Ссылка = СсылкаНаСправочникПоИмениФайла(ЭлементОтчет.Имя);
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
		ОбъектЗагрузки.Ссылка = СсылкаНаСправочникПоНаименованию(ОбъектЗагрузки.Имя);
	КонецЕсли;						
	
	Если НЕ ЗначениеЗаполнено(ОбъектЗагрузки.Ссылка) Тогда
		ОбъектЗагрузки.Ссылка = ПустаяСсылкаНаСправочник();
	КонецЕсли;

КонецПроцедуры

// Определяет ссылку на справочник внешних отчетов и обработок по уникальному идентификатору
//
// Параметры:
//  УникальныйИдентификаторСсылки - УникальныйИдентификатор - Уникальный идентификатор ссылки справочника
// 
// Возвращаемое значение:
//   - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Функция СсылкаНаСправочникПоУникальномуИдентификатору(УникальныйИдентификаторСсылки) Экспорт
	
	СсылкаПоИдентификатору = Справочники[МетаданныеСправочника].ПолучитьСсылку(УникальныйИдентификаторСсылки);
	
	Если СсылкаСуществует(СсылкаПоИдентификатору) Тогда
		
		Возврат СсылкаПоИдентификатору;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Записывает двоичные данные объекта в хранилище элемента справочника
//
// Параметры:
//  ДвоичныеДанныеОбъекта	 - ДвоичныеДанные - Двоичные данные файла объекта
//  СсылкаНаОбъект			 - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Процедура ЗаписатьДанныеОбъектаВХранилище(ДвоичныеДанныеОбъекта, СсылкаНаОбъект, ПутьФайлаОбъекта) Экспорт
	
	НачатьТранзакцию();
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник." + МетаданныеСправочника);
	ЭлементБлокировки.УстановитьЗначение("Ссылка", СсылкаНаОбъект);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	Блокировка.Заблокировать();
	
	ОбъектСправочника = СсылкаНаОбъект.ПолучитьОбъект();
	ОбъектСправочника[РеквизитХранилище] = Новый ХранилищеЗначения(ДвоичныеДанныеОбъекта);
	
	Если ОбновлятьРегистрационныеДанныеПриЗагрузке Тогда
		
		МодульДополнительныеОтчетыИОбработки = ОбщийМодуль("ДополнительныеОтчетыИОбработки");
		АдресДанныхОбработки = ПоместитьВоВременноеХранилище(ДвоичныеДанныеОбъекта);
		
		ПараметрыРегистрации = Новый Структура;
		ПараметрыРегистрации.Вставить("Успех", Ложь);
		ПараметрыРегистрации.Вставить("АдресДанныхОбработки", АдресДанныхОбработки);
		
		Ключи = Новый Структура("ИмяФайла, ЭтоОтчет, ОтключатьПубликацию, ОтключатьКонфликтующие, Конфликтующие");
		ДополнитьСтруктуру(ПараметрыРегистрации, Ключи, Ложь);
		
		ПараметрыРегистрации.ОтключатьПубликацию = Ложь;
		ПараметрыРегистрации.ОтключатьКонфликтующие = Ложь;
		ПараметрыРегистрации.Конфликтующие = Новый СписокЗначений;

		МассивПодстрок = _СтрРазделить(ПутьФайлаОбъекта, "\", Ложь);
		ПараметрыРегистрации.ИмяФайла = МассивПодстрок.Получить(МассивПодстрок.ВГраница());
		РасширениеФайла = ВРег(Прав(ПараметрыРегистрации.ИмяФайла, 3));
		
		Если РасширениеФайла = "ERF" Тогда
			ПараметрыРегистрации.ЭтоОтчет = Истина;
		ИначеЕсли РасширениеФайла = "EPF" Тогда
			ПараметрыРегистрации.ЭтоОтчет = Ложь;
		Иначе
			ВызватьИсключение "Неизвестный тип внешнего отчета / обработки.";
		КонецЕсли;

		КомандыСохраненные = ОбъектСправочника.Команды.Выгрузить();
		
		РезультатРегистрации = МодульДополнительныеОтчетыИОбработки.ЗарегистрироватьОбработку(ОбъектСправочника, ПараметрыРегистрации);
		
		Если ЭтоАдресВременногоХранилища(АдресДанныхОбработки) Тогда
			УдалитьИзВременногоХранилища(АдресДанныхОбработки);			
		КонецЕсли;
		
		РегистрацияВыполненаУспешно = Ложь;
		Если РезультатРегистрации.Свойство("Успешно")
			И РезультатРегистрации.Успешно Тогда
			РегистрацияВыполненаУспешно = Истина;
		ИначеЕсли РезультатРегистрации.Свойство("Успех")
			И РезультатРегистрации.Успех Тогда
			РегистрацияВыполненаУспешно = Истина;
		КонецЕсли;			
		
		Если РезультатРегистрации.ИмяОбъектаЗанято Тогда
			ПредставлениеЗанявших = "";
			Для Каждого ЭлементСписка Из ПараметрыРегистрации.Конфликтующие Цикл
				Если СтрДлина(ПредставлениеЗанявших) > 80 Тогда
					ПредставлениеЗанявших = ПредставлениеЗанявших + "... ";
					Прервать;
				КонецЕсли;
				ПредставлениеЗанявших = ПредставлениеЗанявших
				+ ?(ПредставлениеЗанявших = "", "", ", ")
				+ """" + СокрЛП(ЭлементСписка.Представление) + """";
			КонецЦикла;
			ПараметрыРегистрации.Вставить("ПредставлениеЗанявших", ПредставлениеЗанявших);
			ПараметрыРегистрации.Вставить("КоличествоКонфликтующих", ПараметрыРегистрации.Конфликтующие.Количество());
			
			СообщениеОбОшибке = "При регистрации """ + СсылкаНаОбъект + """ обнаружены конфликты: " 
				+ ПараметрыРегистрации.ПредставлениеЗанявших + "(всего конфликтов "
				+ ПараметрыРегистрации.КоличествоКонфликтующих
				+ ")";
			Если ОбновитьДвоичныеДанныеПриОшибкеРегистрации Тогда
				СообщитьПользователю(СообщениеОбОшибке);	
			Иначе
				Если ТранзакцияАктивна() Тогда
					ОтменитьТранзакцию();
				КонецЕсли;
				
				ВызватьИсключение СообщениеОбОшибке;
			КонецЕсли;					
			
		ИначеЕсли НЕ РегистрацияВыполненаУспешно Тогда
			
			СообщениеОбОшибке = "Не удалось выполнить регистрацию для """ + СсылкаНаОбъект + """";
			Если ОбновитьДвоичныеДанныеПриОшибкеРегистрации Тогда
				СообщитьПользователю(СообщениеОбОшибке);	
			Иначе
				Если ТранзакцияАктивна() Тогда
					ОтменитьТранзакцию();
				КонецЕсли;
			
				ВызватьИсключение СообщениеОбОшибке;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ОбъектСправочника.Записать();
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры

// Создать схему компоновки для основного справочника внешних отчетов и обработок
// 
// Возвращаемое значение:
//   - СхемаКомпоновкиДанных - Схема для работы со справочником внешних отчетов и обработок. 
//
Функция СоздатьСхемуКомпоновкиДляОсновногоСправочника() Экспорт
	
	ПоддерживаютсяГруппы = СправочникИерархическийСГрупами();
	
	ЗапросКПолямСправочника = 
		"ВЫБРАТЬ
        |    *
        |ИЗ
        |    Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
		|ГДЕ
		|	&ПоддерживаютсяГруппы";
	
	Если ПоддерживаютсяГруппы Тогда
		ЗапросКПолямСправочника = СтрЗаменить(
			ЗапросКПолямСправочника,
			"&ПоддерживаютсяГруппы",
			"ЭтоГруппа = ЛОЖЬ");
	Иначе
		ЗапросКПолямСправочника = СтрЗаменить(
			ЗапросКПолямСправочника,
			"&ПоддерживаютсяГруппы",
			"Истина");
	КонецЕсли;
	
	ЗапросКПолямСправочника = СтрЗаменить(
		ЗапросКПолямСправочника,
		"Справочник.ДополнительныеОтчетыИОбработки",
		"Справочник." + МетаданныеСправочника);
	
	Схема = СоздатьСхемуКомпоновкиДанных(
		ЗапросКПолямСправочника,
		Неопределено,
		Истина);
	
	Возврат Схема;
	
КонецФункции

// Описания файлов для удаления перед выгрузкой
// 
// Возвращаемое значение:
//   - Массив - Массив со строками, описывающими файлы для удаления
//
Функция МассивОписанияФайловДляУдаленияПередВыгрузкой() Экспорт
	
	МассивОписанияФайлов = Новый Массив;
	// Файл конфигурации соответствия обработок и элементов справочника
	МассивОписанияФайлов.Добавить("config.json");
	// Файлы внешних обработок
	МассивОписанияФайлов.Добавить("*.epf");
	// Файлы внешних отчетов
	МассивОписанияФайлов.Добавить("*.erf");
	
	Возврат МассивОписанияФайлов;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Определяет ссылку на справочник внешних отчетов и обработок по регистрационным данным обработки (по формату БСП)
//
// Параметры:
//  ПолныйПутьКФайлу - Строка - Полный путь к файлу внешнего отчета / обработки
// 
// Возвращаемое значение:
//   - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Функция СсылкаНаСправочникПоРегистрационнымДанным(ПолныйПутьКФайлу)
	
	СсылкаНаСправочник = Неопределено;
	
	ИнформацияОФайле = Новый Файл(ПолныйПутьКФайлу);
	Если ИнформацияОФайле.Существует() Тогда
		
		РасширениеФайла = ВРег(ИнформацияОФайле.Расширение);	
		Если РасширениеФайла = ".EPF" Тогда
			МенеджерОбъекта = ВнешниеОбработки;	
		ИначеЕсли РасширениеФайла = ".ERF" Тогда
			МенеджерОбъекта = ВнешниеОтчеты;
		Иначе	
			МенеджерОбъекта = Неопределено;
		КонецЕсли;
		
		Если НЕ МенеджерОбъекта = Неопределено Тогда
		
			Попытка
					
				ВнешнийОбъект = МенеджерОбъекта.Создать(ПолныйПутьКФайлу, Ложь);
				СведенияОВнешнейОбработке = ВнешнийОбъект.СведенияОВнешнейОбработке();
				МетаданныеВнешнегоОбъекта = ВнешнийОбъект.Метаданные();
				ИмяОбъекта = МетаданныеВнешнегоОбъекта.Имя;
				
				Если НЕ ЗначениеЗаполнено(СсылкаНаСправочник) Тогда
					СсылкаНаСправочник = СсылкаНаСправочникПоИмениОбъекта(ИмяОбъекта);
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(СсылкаНаСправочник) Тогда
					СсылкаНаСправочник = СсылкаНаСправочникПоИмениФайла(ИнформацияОФайле.Имя);
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(СсылкаНаСправочник) Тогда
					СсылкаНаСправочник = СсылкаНаСправочникПоНаименованию(СведенияОВнешнейОбработке.Наименование);
				КонецЕсли;
				
			Исключение
				
				СсылкаНаСправочник = ПустаяСсылкаНаСправочник();
				
			КонецПопытки;
			
		КонецЕсли;
		
	Иначе
		
		СсылкаНаСправочник = ПустаяСсылкаНаСправочник();
		
	КонецЕсли;
	
	Возврат СсылкаНаСправочник;
	
КонецФункции

// Определяет ссылку на справочник внешних отчетов и обработок по имени объекта
//
// Параметры:
//  Наименование - Строка - Имя внешнего отчета или обработки
// 
// Возвращаемое значение:
//   - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Функция СсылкаНаСправочникПоИмениОбъекта(ИмяОбъекта)
	
	КоллекцияРеквизитов = Метаданные.Справочники[МетаданныеСправочника].Реквизиты;
	Если КоллекцияРеквизитов.Найти("ИмяОбъекта") = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СсылкаПоНаименованию = Справочники[МетаданныеСправочника].НайтиПоРеквизиту("ИмяОбъекта", ИмяОбъекта);
	
	Если СсылкаСуществует(СсылкаПоНаименованию) Тогда
		
		Возврат СсылкаПоНаименованию;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Определяет ссылку на справочник внешних отчетов и обработок по имени файла
//
// Параметры:
//  Наименование - Строка - Имя файла отчета или обработки
// 
// Возвращаемое значение:
//   - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Функция СсылкаНаСправочникПоИмениФайла(ИмяФайла)
	
	КоллекцияРеквизитов = Метаданные.Справочники[МетаданныеСправочника].Реквизиты;
	Если КоллекцияРеквизитов.Найти("ИмяФайла") = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СсылкаПоНаименованию = Справочники[МетаданныеСправочника].НайтиПоРеквизиту("ИмяФайла", ИмяФайла);
	
	Если СсылкаСуществует(СсылкаПоНаименованию) Тогда
		
		Возврат СсылкаПоНаименованию;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Определяет ссылку на справочник внешних отчетов и обработок по наименованию
//
// Параметры:
//  Наименование - Строка - Имя внешнего отчета или обработки
// 
// Возвращаемое значение:
//   - СправочникСсылка - Ссылка на элемент справочника внешних отчетов и обработок
//
Функция СсылкаНаСправочникПоНаименованию(Наименование)
	
	СсылкаПоНаименованию = Справочники[МетаданныеСправочника].НайтиПоНаименованию(Наименование, Истина);
	
	Если СсылкаСуществует(СсылкаПоНаименованию) Тогда
		
		Возврат СсылкаПоНаименованию;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

Функция УдалитьФайлыПередВыгрузкой()
	
	МаскиУдаленияФайлов = МассивОписанияФайловДляУдаленияПередВыгрузкой();
	
	Для Каждого МаскаУдаленияФайлов Из МаскиУдаленияФайлов Цикл
	
		УдалитьФайлы(ОсновнойКаталогВыгрузки, МаскаУдаленияФайлов);
		
	КонецЦикла;
	
КонецФункции
	
// Пустая ссылка на справочник
// 
// Возвращаемое значение:
//   - СправочникСсылка - Пустая ссылка на справочник внешних отчетов и обработок
//
Функция ПустаяСсылкаНаСправочник()
	
	Если ЗначениеЗаполнено(МетаданныеСправочника) Тогда
	
		Возврат Справочники[МетаданныеСправочника].ПустаяСсылка();
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - что делать в местах пересечения ключей источника и приемника:
//                                       Истина - заменять значения приемника (самый быстрый способ),
//                                       Ложь   - не заменять значения приемника (пропускать),
//                                       Неопределено - значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'");
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

Функция _СтрРазделить(Знач Стр, Разделитель, ВключатьПустые = Истина) Экспорт
	
	РезультатирующийМассив = Новый Массив;
	
	МассивСтрок = РазложитьСтрокуВМассивПодстрок(Стр, Разделитель);
	
	Для Каждого Стр Из МассивСтрок Цикл
		
		Если ВключатьПустые = Ложь
			И НЕ ЗначениеЗаполнено(Стр) Тогда
			Продолжить;
		КонецЕсли;
		
		РезультатирующийМассив.Добавить(Стр);
		
	КонецЦикла;
	
	Возврат РезультатирующийМассив;
	
КонецФункции

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
// В случаях, когда разделителем является строка из одного символа, и не используется параметр СокращатьНепечатаемыеСимволы,
// рекомендуется использовать функцию платформы СтрРазделить.
//
// Параметры:
//  Значение               - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат;
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//  СокращатьНепечатаемыеСимволы - Булево - сокращать непечатаемые символы по краям каждой из найденных подстрок.
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Пример:
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",")
//  - возвратит массив из 5 элементов, три из которых  - пустые: "", "один", "", "два", "";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина)
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(" один   два  ", " ")
//  - возвратит массив из двух элементов: "один", "два";
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("")
//  - возвратит пустой массив;
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("",,Ложь)
//  - возвратит массив с одним элементом: ""(пустая строка);
//  СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок("", " ")
//  - возвратит массив с одним элементом: "" (пустая строка).
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Значение, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено, 
	СокращатьНепечатаемыеСимволы = Ложь)
	
	Если Разделитель = "," 
		И ПропускатьПустыеСтроки = Неопределено 
		И СокращатьНепечатаемыеСимволы Тогда 
		
		Результат = _СтрРазделить(Значение, ",", Ложь);
		Для Индекс = 0 По Результат.ВГраница() Цикл
			Результат[Индекс] = СокрЛП(Результат[Индекс])
		КонецЦикла;
		Возврат Результат;
		
	КонецЕсли;
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Значение) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = _СтрНайти(Значение, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Значение, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Если СокращатьНепечатаемыеСимволы Тогда
				Результат.Добавить(СокрЛП(Подстрока));
			Иначе
				Результат.Добавить(Подстрока);
			КонецЕсли;
		КонецЕсли;
		Значение = Сред(Значение, Позиция + СтрДлина(Разделитель));
		Позиция = _СтрНайти(Значение, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Значение) Тогда
		Если СокращатьНепечатаемыеСимволы Тогда
			Результат.Добавить(СокрЛП(Значение));
		Иначе
			Результат.Добавить(Значение);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Находит первое вхождение искомой строки как подстроки в исходной строке. 
// Сравнение выполняется с учетом регистра.
//
// Параметры:
//  Строка				 - Строка	 - Исходная строка.
//  СтрокаПоиска		 - Строка	 - Искомая строка.
//  НаправлениеПоиска	 - Строка	 - Указывает направление поиска подстроки в строке. 
// 									   Возможные варианты: "СНачала" и "СКонца".
//  НачальнаяПозиция	 - Число	 - Указывает позицию в строке, с которой начинается поиск.
//  НомерВхождения		 - Число	 - Указывает номер вхождения искомой строки в исходной строке.
// 
// Возвращаемое значение:
//  Число - Позиция первого знака найденной подстроки. Если строка не содержит указанной подстроки, то возращается 0.
//
Функция _СтрНайти(Знач Строка, Знач СтрокаПоиска, Знач НаправлениеПоиска = "СНачала", Знач НачальнаяПозиция = 1
	, Знач НомерВхождения = 1)
	
	ДлинаСтроки = СтрДлина(Строка);
	ДлинаСтрокиПоиска = СтрДлина(СтрокаПоиска);
	
	Если НачальнаяПозиция = 0
		Или НомерВхождения = 0
		Или ДлинаСтроки < НачальнаяПозиция	
		Или (НаправлениеПоиска <> "СНачала" И НаправлениеПоиска <> "СКонца") Тогда
		
		Возврат 0;	
	КонецЕсли; 
	
	Если НаправлениеПоиска = "СКонца" Тогда
		Строка = СтрокаЗадомНаперед(Строка); 
		СтрокаПоиска = СтрокаЗадомНаперед(СтрокаПоиска); 
	КонецЕсли;
	
	Если НачальнаяПозиция = 1 Тогда
		ДлинаПройденнойЧастиСтроки = 0;
		ОставшаясяЧастьСтроки = Строка;
	Иначе
		ДлинаПройденнойЧастиСтроки = НачальнаяПозиция - 1;
		ОставшаясяЧастьСтроки = Прав(Строка, ДлинаСтроки - НачальнаяПозиция + 1);
	КонецЕсли;
	
	Если НомерВхождения > СтрЧислоВхождений(ОставшаясяЧастьСтроки, СтрокаПоиска) Тогда
		Возврат 0;	
	КонецЕсли; 
	
	НомерТекущегоВхождения = 0;
	Пока НомерТекущегоВхождения < НомерВхождения Цикл
		
		ИндексВхождения = Найти(ОставшаясяЧастьСтроки, СтрокаПоиска);
		
		ДлинаПройденнойЧастиСтроки = ДлинаПройденнойЧастиСтроки + СтрДлина(Лев(ОставшаясяЧастьСтроки, ИндексВхождения 
			+ ДлинаСтрокиПоиска - 1));
		
		ОставшаясяЧастьСтроки = Прав(ОставшаясяЧастьСтроки, СтрДлина(ОставшаясяЧастьСтроки) - (ИндексВхождения 
			+ ДлинаСтрокиПоиска - 1));
		
		НомерТекущегоВхождения = НомерТекущегоВхождения + 1;
		
	КонецЦикла;	
	
	Если НаправлениеПоиска = "СКонца" Тогда
		Возврат ДлинаСтроки - ДлинаПройденнойЧастиСтроки + ДлинаСтрокиПоиска;
	Иначе	
		Возврат ДлинаПройденнойЧастиСтроки + 1 - ДлинаСтрокиПоиска;
	КонецЕсли;
	
КонецФункции

// Возвращает строку, написанную задом наперед.
//
// Параметры:
//  Строка	 - Строка - Текст для обработка.
// 
// Возвращаемое значение:
//  Строка - Строка развернутая задом наперед.
//
Функция СтрокаЗадомНаперед(Знач Строка)
	
	Результат = "";
	
	ДлинаСтроки = СтрДлина(Строка); 		
	Для Счетчик = 0 По ДлинаСтроки - 1 Цикл			
		
		Индекс = ДлинаСтроки - Счетчик;			
		Символ = Сред(Строка, Индекс, 1);
		
		Результат = Результат + Символ;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОбщийМодуль(Имя)
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда	
		Модуль = Вычислить(Имя);
	КонецЕсли;
		
	Возврат Модуль;
	
КонецФункции

Функция ПодсистемаСуществует(ПолноеИмяПодсистемы)
	
	МодульСтандартныеПодсистемыПовтИсп = ОбщийМодуль("СтандартныеПодсистемыПовтИсп");
	Если МодульСтандартныеПодсистемыПовтИсп = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		
		ИменаПодсистем = МодульСтандартныеПодсистемыПовтИсп.ИменаПодсистем();
		Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

Процедура ОбработкаПроверкиЗаполненияОбщая(Отказ)

	Если НЕ ЗначениеЗаполнено(МетаданныеСправочника) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнено имя справочника с внешних отчетов и обработок.'"),,
			"МетаданныеСправочника",
			"Объект",				
			Отказ);
			
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(РеквизитПредставление) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнено имя реквизита с представлением внешнего отчета / обработки.'"),,
			"РеквизитПредставление",
			"Объект",				
			Отказ);
			
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(РеквизитИмя) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнено имя реквизита с именем внешнего отчета / обработки.'"),,
			"РеквизитИмя",
			"Объект",				
			Отказ);
			
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(РеквизитХранилище) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнено имя реквизита с хранилищем двоичных данных внешнего отчета / обработки.'"),,
			"РеквизитХранилище",
			"Объект",				
			Отказ);
			
	КонецЕсли;
		
	Если НЕ ЗначениеЗаполнено(РеквизитВид) Тогда
		
		СообщитьПользователю(
			НСтр("ru = 'Не заполнено имя реквизита с видом внешнего отчета / обработки.'"),,
			"РеквизитВид",
			"Объект",				
			Отказ);
			
	КонецЕсли;
	   	
КонецПроцедуры

Функция ОпределитьТипВнешнегоОбъекта(ЗначениеТипа)
	
	ТипВнешнегоОбъекта = "Неизвестно";
	
	Если ТипЗнч(ЗначениеТипа) = Тип("Строка") Тогда
		
		ВидОбработкиСтрокой = ВРег(ЗначениеТипа);
		
		Если Найти(ВидОбработкиСтрокой, ".EPF") > 0 Тогда
			
			ТипВнешнегоОбъекта = "Обработка";	
			
		ИначеЕсли Найти(ВидОбработкиСтрокой, ".ERF") > 0 Тогда
			
			ТипВнешнегоОбъекта = "Отчет";	
			
		КонецЕсли;
		
	Иначе
		
		Если НЕ Метаданные.Перечисления.Найти("ВидыДополнительныхОтчетовИОбработок") = Неопределено Тогда
			
			УстановитьБезопасныйРежим(Истина);
			
			Выполнить(
				"Если ЗначениеТипа = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет
				|	ИЛИ ЗначениеТипа = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет Тогда
				|	
				|	ТипВнешнегоОбъекта = ""Отчет"";
				|	
				|Иначе
				|	
				|	ТипВнешнегоОбъекта = ""Обработка"";
				|	
				|КонецЕсли;");
			
			УстановитьБезопасныйРежим(Ложь);
			
		КонецЕсли;
		
	КонецЕсли;	
	
	Возврат ТипВнешнегоОбъекта;
	
КонецФункции

Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	Сообщение.КлючДанных = КлючДанных;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Проверяет физическое наличие записи в справочнике дополнительных отчетов и обработок
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка)
    
    ТекстЗапроса = "
        |ВЫБРАТЬ
        |    Ссылка
        |ИЗ
        |    Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
        |ГДЕ
        |    Ссылка = &Ссылка
        |";
			
    Запрос = Новый Запрос;
    Запрос.Текст = ТекстЗапроса;
	
	Запрос.Текст = СтрЗаменить(
		Запрос.Текст,
		"Справочник.ДополнительныеОтчетыИОбработки",
		"Справочник." + МетаданныеСправочника);
	
    Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
    
    УстановитьПривилегированныйРежим(Истина);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции

// НаборДанных (Типы: Строка, запрос, ТаблицаЗначений, ДеревоЗначений)
// Искомый набор данных
//
// СтруктураРесурсов (Тип: Структура) - Структура полей ресурсов, где ключ - ИмяПоля, Значение(Строка) - Агрегатная функция
//
// ВноситьПоляВыбора (Тип: Булево) - Флаг добавление полей набора
//
// ИмяСтандартногоМакетаОформления (Тип: Строка) - Имя макета оформления 
//
Функция СоздатьСхемуКомпоновкиДанных(НаборДанных, СтруктураРесурсов = Неопределено, АвтоЗаполнениеДоступныхПолей = Истина, ИмяСтандартногоМакетаОформления = "")
	
	СКД = Новый СхемаКомпоновкиДанных;
	
	// Заполнение основных данных схемы
	ИсточникДанных = СКД.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя = "ИсточникДанных";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	Если ТипЗнч(НаборДанных) = Тип("Строка") Или ТипЗнч(НаборДанных) = Тип("Запрос") Тогда
		ТекущийНаборДанных = СКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
		ТекущийНаборДанных.Имя = "ОсновнойНабор";
		ТекущийНаборДанных.Запрос = ?(ТипЗнч(НаборДанных) = Тип("Строка"),НаборДанных,НаборДанных.Текст);
		ТекущийНаборДанных.ИсточникДанных = "ИсточникДанных";			
		ТипНабора = "Запрос";
		ТекущийНаборДанных.АвтоЗаполнениеДоступныхПолей = АвтоЗаполнениеДоступныхПолей;
	ИначеЕсли ТипЗнч(НаборДанных) = Тип("ТаблицаЗначений") Или ТипЗнч(НаборДанных) = Тип("ДеревоЗначений") Тогда
		ТекущийНаборДанных = СКД.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
		ТекущийНаборДанных.Имя = "ОсновнойНабор";
		ТекущийНаборДанных.ИмяОбъекта = "ТаблицаИсточник";	
		ТекущийНаборДанных.ИсточникДанных = "ИсточникДанных";			
		ТипНабора = "Объект";
	Иначе			
		Возврат Неопределено;
	КонецЕсли;	
			
	НастройкиПоУмолчанию = СКД.НастройкиПоУмолчанию;
	
	// Создание структуры.
	// Группировка, детальные записи и автоматически выбранное поле
	Группировка = НастройкиПоУмолчанию.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Группировка.Использование = Истина;			
	АвтоПоле = Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	АвтоПоле.Использование = Истина;
	
	КоллекцияКолонок = Новый ТаблицаЗначений;
	КоллекцияКолонок.Колонки.Добавить("Имя");
	КоллекцияКолонок.Колонки.Добавить("ТипЗначения");
	КоллекцияКолонок.Колонки.Добавить("Заголовок");
	
	Если ТипНабора = "Запрос" Тогда
		ПостроительЗапроса = Новый ПостроительЗапроса;
		Если ТипЗнч(НаборДанных) = Тип("Строка") Тогда
			ПостроительЗапроса.Текст = СокрЛП(НаборДанных);
		Иначе 
			ПостроительЗапроса.Текст = СокрЛП(НаборДанных.Текст);
		КонецЕсли;
		ПостроительЗапроса.ЗаполнитьНастройки();
		
		Для каждого ВыбранноеПоле Из ПостроительЗапроса.ВыбранныеПоля Цикл	
			НоваяКолонка = КоллекцияКолонок.Добавить();
			НоваяКолонка.Имя = ВыбранноеПоле.Имя;			
			НоваяКолонка.ТипЗначения = ПостроительЗапроса.ДоступныеПоля[ВыбранноеПоле.ПутьКДанным].ТипЗначения;
			НоваяКолонка.Заголовок = ВыбранноеПоле.Представление
		КонецЦикла;
		
	ИначеЕсли ТипНабора = "Объект" Тогда
		
		Для каждого Колонка Из НаборДанных.Колонки Цикл			
			НоваяКолонка = КоллекцияКолонок.Добавить();
			НоваяКолонка.Имя = Колонка.Имя;
			НоваяКолонка.ТипЗначения = Колонка.ТипЗначения;
			НоваяКолонка.Заголовок = Колонка.Имя;									
		КонецЦикла;
		
	КонецЕсли;
	
	// Добавление ресурсов
	Если ТипЗнч(СтруктураРесурсов) = Тип("Структура") Тогда			
		Для Каждого ЭлСтруктуры Из СтруктураРесурсов Цикл
			// Проверка, а существует ли поле ресурса среди полей набора
			Если КоллекцияКолонок.Найти(ЭлСтруктуры.Ключ) <> Неопределено Тогда
				// Проверка на правильность указания агрегатной функции
				Если    ЭлСтруктуры.Значение = "Сумма" 
					ИЛИ ЭлСтруктуры.Значение = "Среднее"
					ИЛИ ЭлСтруктуры.Значение = "Максимум"
					ИЛИ ЭлСтруктуры.Значение = "Минимум"
					ИЛИ ЭлСтруктуры.Значение = "Количество" Тогда
					
					ПолеРесурса             = СКД.ПоляИтога.Добавить();
					ПолеРесурса.ПутьКДанным = ЭлСтруктуры.Ключ;
					ПолеРесурса.Выражение   = ЭлСтруктуры.Значение + "(" + ЭлСтруктуры.Ключ + ")";					
					
				ИначеЕсли ЭлСтруктуры.Значение = "КоличествоРазличные" Тогда                      
					
					ПолеРесурса             = СКД.ПоляИтога.Добавить();
					ПолеРесурса.ПутьКДанным = ЭлСтруктуры.Ключ;
					ПолеРесурса.Выражение   = "Количество(Различные " + ЭлСтруктуры.Ключ + ")";
					
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;                             			
	КонецЕсли;
		
	// Добавление полей в набор		
	Для каждого НоваяКолонка Из КоллекцияКолонок Цикл			
		ПолеНабора = ТекущийНаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
		ПолеНабора.Заголовок = СокрЛП(НоваяКолонка.Заголовок);
		ПолеНабора.Поле = СокрЛП(НоваяКолонка.Имя);
		ПолеНабора.ПутьКДанным = СокрЛП(НоваяКолонка.Имя);
		
		// Удалим неопределено и NULL
		Массив = Новый Массив;
		Для Каждого ТекущийТип Из НоваяКолонка.ТипЗначения.Типы() Цикл
			Если ТекущийТип = Тип("Неопределено") 
				Или ТекущийТип = Тип("NULL") 
				Или ТекущийТип = Неопределено Или ТекущийТип = Null Тогда 
				Продолжить; 
			КонецЕсли;
			Массив.Добавить(ТекущийТип);
		КонецЦикла;
		ПолеНабора.ТипЗначения = Новый ОписаниеТипов(Массив,НоваяКолонка.ТипЗначения.КвалификаторыЧисла,НоваяКолонка.ТипЗначения.КвалификаторыСтроки,НоваяКолонка.ТипЗначения.КвалификаторыДаты);
						
		ВыбранноеПолеКомпоновкиДанных = НастройкиПоУмолчанию.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));			
		ВыбранноеПолеКомпоновкиДанных.Поле = Новый ПолеКомпоновкиДанных(ПолеНабора.ПутьКДанным);
		ВыбранноеПолеКомпоновкиДанных.Использование = Истина;
	КонецЦикла;
		
	// Оформление
	Если Не ПустаяСтрока(ИмяСтандартногоМакетаОформления) Тогда
		ЗначениеПараметраВывода = НастройкиПоУмолчанию.ПараметрыВывода.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("МакетОформления"));
		ЗначениеПараметраВывода.Значение = ИмяСтандартногоМакетаОформления;
		ЗначениеПараметраВывода.Использование = Истина;
	КонецЕсли;
		
	Возврат СКД;
	
КонецФункции

Функция ПодготовитьИмяФайла(Знач ИсходноеИмя)
	
    ПодготовленноеИмя = ИсходноеИмя;
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "\", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "/", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, ":", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "*", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "?", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, """", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "<", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, ">", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "|", "");
    ПодготовленноеИмя = СтрЗаменить(ПодготовленноеИмя, "+", "");
    
    Возврат ПодготовленноеИмя;
	
КонецФункции

Функция НазначениеОбработки() 
	
	МассивНазначенийОбработки = Новый Массив;
	 
	Возврат МассивНазначенийОбработки;
	
КонецФункции

Функция ТаблицаКомандОбработки() 
	
	тзКоманд = Новый ТаблицаЗначений;
	тзКоманд.Колонки.Добавить("Идентификатор"           , Новый ОписаниеТипов("Строка"));
	тзКоманд.Колонки.Добавить("Представление"           , Новый ОписаниеТипов("Строка"));
	тзКоманд.Колонки.Добавить("ПоказыватьОповещение"    , Новый ОписаниеТипов("Булево"));
	тзКоманд.Колонки.Добавить("Модификатор"             , Новый ОписаниеТипов("Строка"));
	тзКоманд.Колонки.Добавить("Использование"           , Новый ОписаниеТипов("Строка"));
	тзКоманд.Колонки.Добавить("Скрыть"                  , Новый ОписаниеТипов("Булево"));
	
	ДобавитьКоманду(тзКоманд, НСтр("ru='ОбозревательКриптографии'"), НСтр("ru='Обозреватель криптографии'"), Ложь, "ОткрытиеФормы", "", Ложь);
	
	Возврат тзКоманд;
	
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Идентификатор, Представление, ПоказыватьОповещение, Использование, Модификатор, Скрыть)
	
	строкаКоманды = ТаблицаКоманд.Добавить();
	строкаКоманды.Идентификатор = Идентификатор;
	строкаКоманды.Представление = Представление;
	строкаКоманды.ПоказыватьОповещение = ПоказыватьОповещение;
	строкаКоманды.Использование = Использование;
	строкаКоманды.Модификатор = Модификатор;
	строкаКоманды.Скрыть = Скрыть;
	
КонецПроцедуры

Процедура ВыполнитьИнициализацию()
	
	ИмяСтандартногоСправочника = "ДополнительныеОтчетыИОбработки";	
	СтандартныйСправочник = Метаданные.Справочники.Найти(ИмяСтандартногоСправочника);
	
	ИмяСправочника_ВнешниеОбработки = "ВнешниеОбработки";	
	Справочник_ВнешниеОбработки = Метаданные.Справочники.Найти(ИмяСправочника_ВнешниеОбработки);
	
	Если НЕ СтандартныйСправочник = Неопределено Тогда
		
		МетаданныеСправочника = ИмяСтандартногоСправочника;		
		РеквизитПредставление = "Наименование";
		
		Если НЕ СтандартныйСправочник.Реквизиты.Найти("ИмяОбъекта") = Неопределено Тогда
			
			РеквизитИмя = "ИмяОбъекта";
			
		Иначе
			
			РеквизитИмя = РеквизитПредставление;
			
		КонецЕсли;
		
		Если НЕ СтандартныйСправочник.Реквизиты.Найти("Вид") = Неопределено Тогда
			
			РеквизитВид = "Вид";
			
		ИначеЕсли НЕ СтандартныйСправочник.Реквизиты.Найти("ИмяФайла") = Неопределено Тогда
			
			РеквизитИмя = "ИмяФайла";
			
		КонецЕсли;
		
		Если НЕ СтандартныйСправочник.Реквизиты.Найти("ХранилищеОбработки") = Неопределено Тогда			
			
			РеквизитХранилище = "ХранилищеОбработки";
			
		Иначе
			
			ТипХранилищеЗначения = Новый ОписаниеТипов("ХранилищеЗначения");
			Для Каждого РеквизитСправочника Из СтандартныйСправочник.Реквизиты Цикл
				
				Если РеквизитСправочника.Тип = ТипХранилищеЗначения
					И НЕ РеквизитСправочника.Имя = "ХранилищеНастроек" Тогда
					
					РеквизитХранилище = РеквизитСправочника.Имя;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		ДоступнаПодсистемаДополнительныеОтчетыИОбработки = Истина;
		ОбщийМодульДополнительныеОтчетыИОбработки = ОбщийМодуль("ДополнительныеОтчетыИОбработки");
		Если ОбщийМодульДополнительныеОтчетыИОбработки = Неопределено Тогда
			ДоступнаПодсистемаДополнительныеОтчетыИОбработки = Ложь;
		КонецЕсли;
		
	ИначеЕсли НЕ Справочник_ВнешниеОбработки = Неопределено Тогда
		
		МетаданныеСправочника = ИмяСправочника_ВнешниеОбработки;		
		РеквизитПредставление = "Наименование";
		РеквизитИмя = РеквизитПредставление;
				
		Если НЕ Справочник_ВнешниеОбработки.Реквизиты.Найти("КомментарийКФайлуИсточнику") = Неопределено Тогда
			
			РеквизитВид = "КомментарийКФайлуИсточнику";
			
		КонецЕсли;
		
		Если НЕ Справочник_ВнешниеОбработки.Реквизиты.Найти("ХранилищеВнешнейОбработки") = Неопределено Тогда			
			
			РеквизитХранилище = "ХранилищеВнешнейОбработки";
			
		Иначе
			
			ТипХранилищеЗначения = Новый ОписаниеТипов("ХранилищеЗначения");
			Для Каждого РеквизитСправочника Из Справочник_ВнешниеОбработки.Реквизиты Цикл
				
				Если РеквизитСправочника.Тип = ТипХранилищеЗначения
					И НЕ РеквизитСправочника.Имя = "ХранилищеНастроек" Тогда
					
					РеквизитХранилище = РеквизитСправочника.Имя;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
	
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(МетаданныеСправочника)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитПредставление)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитИмя)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитХранилище)
		ИЛИ НЕ ЗначениеЗаполнено(РеквизитВид) Тогда
		
		СообщениеОбОшибке =
			НСтр("ru = 'Ошибка инициализации параметров справочника
			|дополнительных отчетов и обработок:
			|
			|Метаданные: " + МетаданныеСправочника + " 
			|РеквизитПредставление: " + РеквизитПредставление + " 
			|РеквизитИмя: " + РеквизитИмя + " 
			|РеквизитХранилище: " + РеквизитХранилище + " 
			|РеквизитВид: " + РеквизитВид + " 
			|
			|Возможно конфигурация не поддерживает работу со справочником
			|дополнительных отчетов и обработок, либо он имеет 
			|нестандартный формат.'");
		
		ВызватьИсключение СообщениеОбОшибке;
		
	КонецЕсли;
	
	Если ДоступнаПодсистемаДополнительныеОтчетыИОбработки Тогда
		ОбновлятьРегистрационныеДанныеПриЗагрузке = Истина;
		ОбновитьДвоичныеДанныеПриОшибкеРегистрации = Истина;
	КонецЕсли;
	
КонецПроцедуры

Функция СправочникИерархическийСГрупами()
	
	ОбъектМетаданныхСправочника = Метаданные.Справочники[МетаданныеСправочника];
	
	Если ОбъектМетаданныхСправочника.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область Инициализация

ВыполнитьИнициализацию();

#КонецОбласти

#КонецЕсли